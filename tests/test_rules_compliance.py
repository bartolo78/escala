"""
Tests for RULES.md compliance.

These tests verify that schedules generated by the application
conform to all rules defined in RULES.md.

Critical Rules (must be strictly enforced):
1. Shift Assignment - 3 shifts/day, each assigned to exactly one worker
2. Worker Availability - unavailable days must be respected
3. Shift Intervals - at least 24h between shifts for same worker  
4. Night Shift Restrictions - workers who can't do nights never get N shift
5. Daily Shift Exclusions - max one shift per worker per day
6. Weekly Participation - all available workers get at least one shift/week
7. Weekday Shift Distribution - equitable weekday distribution before repeats

Flexible Rules (in priority order):
1. Saturday Priority for First Shift
2. Three-Day Weekend Worker Minimization
3. Weekend Shift Limits
4. Consecutive Weekend Shift Avoidance
5. M2 Priority for 18h workers
6-9. Various equity rules
10. Day-of-week distribution
11. 48h rest preference
"""

import pytest
from datetime import date, datetime, timedelta
from collections import defaultdict

from scheduling_engine import generate_schedule
from utils import compute_holidays


@pytest.fixture
def default_workers():
    """Default 15 workers as defined in the application."""
    return [
        {"name": "Tome", "id": "ID001", "color": "#ff0000", "can_night": True, "weekly_load": 12},
        {"name": "Rosa", "id": "ID002", "color": "#ff5400", "can_night": True, "weekly_load": 18},
        {"name": "Lucas", "id": "ID003", "color": "#ffaa00", "can_night": True, "weekly_load": 18},
        {"name": "Bartolo", "id": "ID004", "color": "#ffff00", "can_night": True, "weekly_load": 18},
        {"name": "Gilberto", "id": "ID005", "color": "#aaff00", "can_night": True, "weekly_load": 18},
        {"name": "Pego", "id": "ID006", "color": "#ff0055", "can_night": True, "weekly_load": 18},
        {"name": "Celeste", "id": "ID007", "color": "#00ff55", "can_night": True, "weekly_load": 12},
        {"name": "Sofia", "id": "ID008", "color": "#00ffa9", "can_night": True, "weekly_load": 18},
        {"name": "Lucilia", "id": "ID009", "color": "#00ffff", "can_night": True, "weekly_load": 12},
        {"name": "Teresa", "id": "ID010", "color": "#00a9ff", "can_night": True, "weekly_load": 18},
        {"name": "Fernando", "id": "ID011", "color": "#0054ff", "can_night": False, "weekly_load": 12},
        {"name": "Rosario", "id": "ID012", "color": "#0000ff", "can_night": True, "weekly_load": 12},
        {"name": "Nuno", "id": "ID013", "color": "#5400ff", "can_night": True, "weekly_load": 18},
        {"name": "Filomena", "id": "ID014", "color": "#aa00ff", "can_night": False, "weekly_load": 12},
        {"name": "Angela", "id": "ID015", "color": "#ff00ff", "can_night": True, "weekly_load": 18},
    ]


@pytest.fixture
def empty_unavail(default_workers):
    """Empty unavailability dict."""
    return {w["name"]: [] for w in default_workers}


@pytest.fixture
def empty_req(default_workers):
    """Empty required shifts dict."""
    return {w["name"]: [] for w in default_workers}


@pytest.fixture
def empty_history():
    """Empty history dict."""
    return {}


class TestCriticalRule1_ShiftAssignment:
    """Critical Rule 1: Each shift must be assigned to exactly one worker."""

    def test_all_days_have_three_shifts(self, default_workers, empty_unavail, empty_req, empty_history):
        """Every day should have M1, M2, and N shifts assigned."""
        schedule, weekly, assignments, stats, _ = generate_schedule(
            2026, 1, empty_unavail, empty_req, empty_history, default_workers
        )
        
        if not schedule:
            pytest.skip("Schedule was infeasible")
        
        for day_str, day_shifts in schedule.items():
            assert "M1" in day_shifts, f"Day {day_str} missing M1 shift"
            assert "M2" in day_shifts, f"Day {day_str} missing M2 shift"
            assert "N" in day_shifts, f"Day {day_str} missing N shift"

    def test_each_shift_has_exactly_one_worker(self, default_workers, empty_unavail, empty_req, empty_history):
        """Each shift should be assigned to exactly one worker."""
        schedule, weekly, assignments, stats, _ = generate_schedule(
            2026, 1, empty_unavail, empty_req, empty_history, default_workers
        )
        
        if not schedule:
            pytest.skip("Schedule was infeasible")
        
        worker_names = {w["name"] for w in default_workers}
        for day_str, day_shifts in schedule.items():
            for shift_type, worker_name in day_shifts.items():
                assert worker_name in worker_names, f"Unknown worker {worker_name} on {day_str} {shift_type}"
                # Exactly one worker (not a comma-separated list)
                assert "," not in worker_name, f"Multiple workers assigned to {day_str} {shift_type}"


class TestCriticalRule2_WorkerAvailability:
    """Critical Rule 2: Workers' unavailable days must be respected."""

    def test_unavailable_date_respected(self, default_workers, empty_unavail, empty_req, empty_history):
        """Worker should not be scheduled on unavailable date."""
        unavail = {w["name"]: [] for w in default_workers}
        unavail["Tome"] = ["2026-01-15"]  # Make Tome unavailable on Jan 15
        
        schedule, weekly, assignments, stats, _ = generate_schedule(
            2026, 1, unavail, empty_req, empty_history, default_workers
        )
        
        if not schedule:
            pytest.skip("Schedule was infeasible")
        
        # Check Tome is not assigned on Jan 15
        jan_15 = "2026-01-15"
        if jan_15 in schedule:
            for shift_type, worker in schedule[jan_15].items():
                assert worker != "Tome", f"Tome was assigned {shift_type} on unavailable date {jan_15}"

    def test_unavailable_shift_specific_respected(self, default_workers, empty_unavail, empty_req, empty_history):
        """Worker unavailable for specific shift should be respected."""
        unavail = {w["name"]: [] for w in default_workers}
        unavail["Rosa"] = ["2026-01-20 N"]  # Rosa unavailable for night shift on Jan 20
        
        schedule, weekly, assignments, stats, _ = generate_schedule(
            2026, 1, unavail, empty_req, empty_history, default_workers
        )
        
        if not schedule:
            pytest.skip("Schedule was infeasible")
        
        jan_20 = "2026-01-20"
        if jan_20 in schedule and "N" in schedule[jan_20]:
            assert schedule[jan_20]["N"] != "Rosa", "Rosa was assigned N shift she was unavailable for"


class TestCriticalRule3_ShiftIntervals:
    """Critical Rule 3: At least 24h between shifts for same worker."""

    def test_no_day_shift_after_night_shift(self, default_workers, empty_unavail, empty_req, empty_history):
        """Worker should not have day shift immediately after night shift."""
        schedule, weekly, assignments, stats, _ = generate_schedule(
            2026, 1, empty_unavail, empty_req, empty_history, default_workers
        )
        
        if not schedule:
            pytest.skip("Schedule was infeasible")
        
        # Check all consecutive day pairs
        sorted_days = sorted(schedule.keys())
        for i in range(len(sorted_days) - 1):
            day1 = sorted_days[i]
            day2 = sorted_days[i + 1]
            
            # Check if same day or consecutive days
            d1 = date.fromisoformat(day1)
            d2 = date.fromisoformat(day2)
            if (d2 - d1).days != 1:
                continue
            
            # Worker who worked night on day1 should not work M1 or M2 on day2
            night_worker = schedule[day1].get("N")
            if night_worker:
                day2_m1 = schedule[day2].get("M1")
                day2_m2 = schedule[day2].get("M2")
                assert night_worker != day2_m1, f"{night_worker} worked N on {day1} and M1 on {day2}"
                assert night_worker != day2_m2, f"{night_worker} worked N on {day1} and M2 on {day2}"


class TestCriticalRule4_NightShiftRestrictions:
    """Critical Rule 4: Workers who can't work nights never get N shift."""

    def test_no_night_workers_excluded(self, default_workers, empty_unavail, empty_req, empty_history):
        """Workers with can_night=False should never be assigned N shift."""
        schedule, weekly, assignments, stats, _ = generate_schedule(
            2026, 1, empty_unavail, empty_req, empty_history, default_workers
        )
        
        if not schedule:
            pytest.skip("Schedule was infeasible")
        
        no_night_workers = {w["name"] for w in default_workers if not w.get("can_night", True)}
        # Fernando and Filomena cannot work nights
        assert "Fernando" in no_night_workers
        assert "Filomena" in no_night_workers
        
        for day_str, day_shifts in schedule.items():
            night_worker = day_shifts.get("N")
            if night_worker:
                assert night_worker not in no_night_workers, \
                    f"{night_worker} (can_night=False) was assigned N shift on {day_str}"


class TestCriticalRule5_DailyShiftExclusions:
    """Critical Rule 5: No worker can have more than one shift per day."""

    def test_one_shift_per_worker_per_day(self, default_workers, empty_unavail, empty_req, empty_history):
        """Each worker should have at most one shift per day."""
        schedule, weekly, assignments, stats, _ = generate_schedule(
            2026, 1, empty_unavail, empty_req, empty_history, default_workers
        )
        
        if not schedule:
            pytest.skip("Schedule was infeasible")
        
        for day_str, day_shifts in schedule.items():
            workers_today = []
            for shift_type, worker in day_shifts.items():
                if worker in workers_today:
                    pytest.fail(f"{worker} has multiple shifts on {day_str}")
                workers_today.append(worker)


class TestCriticalRule6_WeeklyParticipation:
    """Critical Rule 6: All workers with available weekdays must get at least one shift per week."""

    def test_all_available_workers_scheduled_each_week(self, default_workers, empty_unavail, empty_req, empty_history):
        """Workers with weekday availability should have at least one shift per ISO week."""
        schedule, weekly, assignments, stats, _ = generate_schedule(
            2026, 1, empty_unavail, empty_req, empty_history, default_workers
        )
        
        if not schedule or not weekly:
            pytest.skip("Schedule was infeasible")
        
        # Check each worker appears in each week's data
        all_workers = {w["name"] for w in default_workers}
        
        for week_key, week_data in weekly.items():
            # weekly structure: week_data[worker_name] = {"hours": ..., "overtime": ..., "undertime": ...}
            # Workers with hours > 0 participated in that week
            workers_in_week = {worker_name for worker_name, data in week_data.items() if data.get("hours", 0) > 0}
            
            # All workers should participate (no one is on vacation by default)
            missing = all_workers - workers_in_week
            assert len(missing) == 0, f"Week {week_key} missing workers: {missing}"


class TestFlexibleRule4_NightShiftRestrictions:
    """Flexible Rule 4: Avoid consecutive weekend shifts for same worker."""

    def test_consecutive_weekends_minimized(self, default_workers, empty_unavail, empty_req, empty_history):
        """Same worker should ideally not work both weekends if others haven't worked any."""
        schedule, weekly, assignments, stats, _ = generate_schedule(
            2026, 1, empty_unavail, empty_req, empty_history, default_workers
        )
        
        if not schedule:
            pytest.skip("Schedule was infeasible")
        
        # Count weekend shifts per worker
        weekend_count = defaultdict(int)
        for day_str, day_shifts in schedule.items():
            d = date.fromisoformat(day_str)
            if d.weekday() >= 5:  # Saturday or Sunday
                for shift_type, worker in day_shifts.items():
                    weekend_count[worker] += 1
        
        # Check that weekend distribution is reasonably balanced
        if weekend_count:
            max_weekends = max(weekend_count.values())
            min_weekends = min(weekend_count.values()) if weekend_count else 0
            # Allow some imbalance but not extreme
            assert max_weekends - min_weekends <= 5, \
                f"Weekend distribution too imbalanced: max={max_weekends}, min={min_weekends}"


class TestFlexibleRule5_M2Priority:
    """Flexible Rule 5: Prioritize M2 over M1 for 18h workers."""

    def test_18h_workers_prefer_m2(self, default_workers, empty_unavail, empty_req, empty_history):
        """18h workers should have more M2 than M1 shifts (preference)."""
        schedule, weekly, assignments, stats, _ = generate_schedule(
            2026, 1, empty_unavail, empty_req, empty_history, default_workers
        )
        
        if not schedule:
            pytest.skip("Schedule was infeasible")
        
        workers_18h = {w["name"] for w in default_workers if w.get("weekly_load") == 18}
        
        m1_count = defaultdict(int)
        m2_count = defaultdict(int)
        
        for day_str, day_shifts in schedule.items():
            m1_worker = day_shifts.get("M1")
            m2_worker = day_shifts.get("M2")
            if m1_worker in workers_18h:
                m1_count[m1_worker] += 1
            if m2_worker in workers_18h:
                m2_count[m2_worker] += 1
        
        # For 18h workers overall, M2 count should be >= M1 count
        total_m1 = sum(m1_count.values())
        total_m2 = sum(m2_count.values())
        # This is a soft preference, so we just check it's reasonable
        assert total_m2 > 0 or total_m1 == 0, "18h workers should have some M2 shifts"


class TestRequiredShifts:
    """Test that required shifts are respected."""

    def test_required_shift_assigned(self, default_workers, empty_unavail, empty_req, empty_history):
        """Worker with required shift should be assigned that shift."""
        req = {w["name"]: [] for w in default_workers}
        req["Lucas"] = ["2026-01-20 M1"]  # Lucas required for M1 on Jan 20
        
        schedule, weekly, assignments, stats, _ = generate_schedule(
            2026, 1, empty_unavail, req, empty_history, default_workers
        )
        
        if not schedule:
            pytest.skip("Schedule was infeasible")
        
        jan_20 = "2026-01-20"
        if jan_20 in schedule:
            assert schedule[jan_20].get("M1") == "Lucas", \
                f"Lucas should have M1 on {jan_20}, got {schedule[jan_20].get('M1')}"


class TestScheduleStructure:
    """Test the structure of schedule output."""

    def test_schedule_dict_structure(self, default_workers, empty_unavail, empty_req, empty_history):
        """Schedule should be a dict with date keys and shift dicts."""
        schedule, weekly, assignments, stats, _ = generate_schedule(
            2026, 1, empty_unavail, empty_req, empty_history, default_workers
        )
        
        if not schedule:
            pytest.skip("Schedule was infeasible")
        
        assert isinstance(schedule, dict)
        for day_str, shifts in schedule.items():
            # Day should be ISO format date string
            date.fromisoformat(day_str)  # Should not raise
            # Shifts should be a dict
            assert isinstance(shifts, dict)

    def test_assignments_list_structure(self, default_workers, empty_unavail, empty_req, empty_history):
        """Assignments should be a list of dicts with required fields."""
        schedule, weekly, assignments, stats, _ = generate_schedule(
            2026, 1, empty_unavail, empty_req, empty_history, default_workers
        )
        
        if not schedule:
            pytest.skip("Schedule was infeasible")
        
        assert isinstance(assignments, list)
        for ass in assignments:
            assert "worker" in ass
            assert "shift" in ass
            assert "date" in ass
            assert "dur" in ass


class TestHolidayHandling:
    """Test holiday-related behavior."""

    def test_january_has_new_year_holiday(self, default_workers, empty_unavail, empty_req, empty_history):
        """January 1st should be treated as a holiday."""
        holidays = compute_holidays(2026, 1)
        assert 1 in holidays, "January 1st should be a holiday"

    def test_schedule_includes_holidays(self, default_workers, empty_unavail, empty_req, empty_history):
        """Schedule should include holiday dates."""
        schedule, weekly, assignments, stats, _ = generate_schedule(
            2026, 1, empty_unavail, empty_req, empty_history, default_workers
        )
        
        if not schedule:
            pytest.skip("Schedule was infeasible")
        
        # Jan 1 2026 is a Thursday - should be in schedule
        assert "2026-01-01" in schedule, "New Year's Day should be in schedule"
